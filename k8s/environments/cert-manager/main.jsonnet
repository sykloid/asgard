local k = import '1.33/main.libsonnet';
local tanka = import 'github.com/grafana/jsonnet-libs/tanka-util/main.libsonnet';
local helm = tanka.helm.new(std.thisFile);

{
  apiVersion: 'tanka.dev/v1alpha1',
  kind: 'Environment',
  metadata: {
    name: 'environments/cert-manager',
  },
  spec: {
    namespace: 'cert-manager',
    resourceDefaults: {},
    expectVersions: {},
    contextNames: ['admin@asgard'],
  },
  data: {
    namespace: k.core.v1.namespace.new($.spec.namespace),
    certManager: helm.template('cert-manager', 'charts/cert-manager', {
      namespace: $.spec.namespace,
      values: {
        crds: {
          enabled: true,
        },
        config: {
          enableGatewayAPI: true,
          featureGates: {
            NameConstraints: true,
          },
        },
        webhook: {
          featureGates: 'NameConstraints=true',
        },
        podDisruptionBudget: {
          enabled: true,
        },
      },
    }),

    trustManager: helm.template('trust-manager', 'charts/trust-manager', {
      namespace: 'cert-manager',
      values: {
      },
    }),

    // The following commented-out resources create the necessary infrastructure
    // to bootstrap a root CA. These include:
    //   - A cluster issuer which generates self-signed certificates.
    //   - A singular root CA certificate generated by the above issuer.

    // selfSignedIssuer: {
    //   apiVersion: 'cert-manager.io/v1',
    //   kind: 'ClusterIssuer',
    //   metadata: {
    //     name: 'asgard-self-signed-issuer',
    //   },
    //   spec: {
    //     selfSigned: {},
    //   },
    // },
    // rootCACert: {
    //   apiVersion: 'cert-manager.io/v1',
    //   kind: 'Certificate',
    //   metadata: {
    //     name: 'asgard-root-ca',
    //     namespace: 'cert-manager',
    //   },
    //   spec: {
    //     isCA: true,
    //     commonName: 'asgard-root-ca',
    //     secretName: 'asgard-root-ca-secret',
    //     duration: '87600h',
    //     renewBefore: '78840h',
    //     privateKey: {
    //       algorithm: 'ECDSA',
    //       size: 256,
    //     },
    //     issuerRef: {
    //       name: 'asgard-self-signed-issuer',
    //       kind: 'ClusterIssuer',
    //       group: 'cert-manager.io',
    //     },
    //   },
    // },

    // For normal use, we save the certificate generated by the rootCACert above,
    // and rehydrate it rather than creating a new cert. The issuer below then
    // generates certificates signed by the hydrated cert.
    rootCAIssuer: {
      apiVersion: 'cert-manager.io/v1',
      kind: 'ClusterIssuer',
      metadata: {
        name: 'asgard-root-ca-issuer',
      },
      spec: {
        ca: {
          secretName: 'asgard-root-ca-secret',
        },
      },
    },

    // Create a trust bundle in each namespace (in the form of a configmap) which
    // contains the information necessary to allow pods to trust certificates
    // signed by our root CA.
    trustBundle: {
      apiVersion: 'trust.cert-manager.io/v1alpha1',
      kind: 'Bundle',
      metadata: {
        name: 'asgard-root-ca-bundle',
        namsepace: 'cert-manager',
      },
      spec: {
        sources: [
          { useDefaultCAs: true },
          { secret: { name: 'asgard-root-ca-secret', key: 'tls.crt' } },
        ],
        target: { configMap: { key: 'trust-bundle.pem' } },
      },
    },
  },
}
